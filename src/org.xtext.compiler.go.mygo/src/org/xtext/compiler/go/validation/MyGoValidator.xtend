/*
 * generated by Xtext 2.14.0
 */
package org.xtext.compiler.go.validation

import java.util.HashMap
import java.util.HashSet
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check
import org.xtext.compiler.go.myGo.ExplicitCast
import org.xtext.compiler.go.myGo.Expression
import org.xtext.compiler.go.myGo.FuncCall
import org.xtext.compiler.go.myGo.FunctionDeclaration
import org.xtext.compiler.go.myGo.IdType
import org.xtext.compiler.go.myGo.LineCommand
import org.xtext.compiler.go.myGo.Model
import org.xtext.compiler.go.myGo.MyGoPackage
import org.xtext.compiler.go.myGo.ReturnStatement
import org.xtext.compiler.go.myGo.Value
import org.xtext.compiler.go.myGo.Variable
import org.xtext.compiler.go.myGo.VariableDeclaration
import org.xtext.compiler.go.myGo.TypeDeclaration
import org.xtext.compiler.go.myGo.ReceiverInstance
import org.xtext.compiler.go.myGo.ForRange
import org.xtext.compiler.go.myGo.Assignment

/**
 * This class contains custom validation rules. 
 *	
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MyGoValidator extends AbstractMyGoValidator {
	
	// user functions
	public static HashMap<String, Function> idNamesToFunctions = new HashMap<String, Function>(); 
	// user types
	public static HashMap<String, String> idNamesToTypes = new HashMap<String, String>();
	
	// variable type
	public HashMap<String, String> variableNamesToTypes;
	// type that the variable was initially declared
	public HashMap<String, String> variableNamesToReceiverTypes;
	
	public final String intc = "int";
	public final String stringc = "string";
	public final String boolc = "bool";
	public final String floatc = "float64";
	public final String nil = "nil";
	public final String voidc = "void";
	
	@Check
	def checkFunctionDeclaration(FunctionDeclaration functionDeclaration){	
		var id = functionDeclaration.id;
		if (checkNameNotDeclared(id, functionDeclaration, MyGoPackage.Literals.FUNCTION_DECLARATION__ID)){
			var f = new Function();
		
			if (functionDeclaration.type !== null){
				var actualType = getActualType(functionDeclaration.type, functionDeclaration, MyGoPackage.Literals.FUNCTION_DECLARATION__TYPE);
				if (actualType == nil){
					return;
				}
				f.returnType = actualType;
			} else {
				f.returnType = voidc;
			}
			
			var uniqueParametersName = new HashSet<String> ();
			variableNamesToTypes = new HashMap<String, String>();
			variableNamesToReceiverTypes = new HashMap<String, String>();
			
			if (functionDeclaration.receiver !== null){
				f.receiverType = functionDeclaration.receiver.idType;
				var actualType = getActualType(functionDeclaration.receiver.idType, functionDeclaration.receiver, MyGoPackage.Literals.RECEIVER__ID_TYPE);
				if (actualType == nil){
					return;
				}
				variableNamesToTypes.put(functionDeclaration.receiver.idName, actualType);
				variableNamesToReceiverTypes.put(functionDeclaration.receiver.idName, functionDeclaration.receiver.idType);
			}
			
			if (functionDeclaration.parameters !== null){
				var parameters = functionDeclaration.parameters.idType
				for (IdType idType: parameters){
					if (uniqueParametersName.contains(idType.id)){
						error(
							"Duplicate argument " + idType.id,
							idType,
							MyGoPackage.Literals.ID_TYPE__ID
						)
						return;
					}
					var actualType = getActualType(idType.type, idType, MyGoPackage.Literals.ID_TYPE__TYPE);
					if (actualType == nil){
						return;
					}
					f.typesList.add(actualType);
					variableNamesToTypes.put(idType.id, actualType);
					variableNamesToReceiverTypes.put(idType.id, idType.type);
				}
			}
			
			idNamesToFunctions.put(id, f);
			
			var returnDeclared = checkLineCommands(functionDeclaration.body.lineCommand, f);
			
			if (!returnDeclared && f.returnType != voidc){
				error(
					"missing return at end of function",
					functionDeclaration,
					MyGoPackage.Literals.FUNCTION_DECLARATION__ID
				)
			}
		}
	}
	
	def boolean checkLineCommands(EList<LineCommand> lineCommands, Function f){
		var returnDeclared = false
		for (LineCommand command: lineCommands){
			if (command instanceof VariableDeclaration){
				checkVariableDeclaration(command);
			} else if (command instanceof ReturnStatement){
				var returnedType = getType(command.expression);
				if (returnedType != nil){
					if (!checkCastAssignment(f.returnType, returnedType)){
						error(
							"Cannot use " + returnedType + " as type " +  
							f.returnType + " in return argument",
							command,
							MyGoPackage.Literals.RETURN_STATEMENT__EXPRESSION
						)
					} else {
						returnDeclared = true;
					}
				} 
			} else if (command instanceof ForRange){
				var expressionType = getType(command.expression);
				if (expressionType != stringc){
					error(
						"Cannot range over " + expressionType,
						command,
						MyGoPackage.Literals.FOR_RANGE__EXPRESSION
					)
				} else {
					var scopeVariableNamesToTypes = new HashMap<String, String>(variableNamesToTypes);
					var scopevariableNamesToReceiverTypes = new HashMap<String, String>(variableNamesToReceiverTypes);
					variableNamesToTypes.put(command.id1, intc);
					variableNamesToReceiverTypes.put(command.id1, intc);
					if (command.id2 !== null){
						variableNamesToTypes.put(command.id2, intc);
						variableNamesToReceiverTypes.put(command.id2, intc);
					}
					if (checkLineCommands(command.lineCommand, f)){
						returnDeclared = true;
					}
					variableNamesToTypes = scopeVariableNamesToTypes;
					variableNamesToReceiverTypes = scopevariableNamesToReceiverTypes;
				}
			} else if (command instanceof FuncCall){
				var funcCallType = getType(command)
				if (funcCallType != nil){
					if (funcCallType != voidc){
						warning(
							command.id + " evaluated but not used",
							command,
							MyGoPackage.Literals.FUNC_CALL__ID
						)
						
					}
				}
			} else if (command instanceof Assignment){
				var idName = command.id;
				if (!variableNamesToTypes.containsKey(idName)){
					error(
						"Undefined: " + idName,
						command,
						MyGoPackage.Literals.ASSIGNMENT__ID
					)
				} else {
					var idType = variableNamesToTypes.get(idName);
					var expressionType = getType(command.expression);
					if (expressionType != nil){
						checkAssignmentType(idType, expressionType, command, MyGoPackage.Literals.ASSIGNMENT__ID);
					}
					
				}
			}
		}
		return returnDeclared;
	}
	
	@Check
	def typeDeclaration(TypeDeclaration typeDeclaration){
		var actualType = getActualType(typeDeclaration.type, typeDeclaration, MyGoPackage.Literals.TYPE_DECLARATION__TYPE);
		if (actualType == nil){
			return;
		}
		var newTypeName = actualType;
		
		var newTypeId = typeDeclaration.id;
		if (checkNameNotDeclared(newTypeId, typeDeclaration,  MyGoPackage.Literals.TYPE_DECLARATION__ID)){
			idNamesToTypes.put(newTypeId, newTypeName);
		}
	}
	
	def checkNameNotDeclared(String idName, EObject e, EAttribute ea){
		if (idNamesToFunctions.containsKey(idName) || idNamesToTypes.containsKey(idName)){
			error(
				idName + " redeclared in this block",
				e,
				ea
			)
			return false;
		} else {
			return true;
		}
	}
	
	def checkVariableDeclaration(VariableDeclaration variableDeclaration) {
		if (variableDeclaration.expression !== null && variableDeclaration.type !== null){	
			var expressionType = getType(variableDeclaration.expression);
			var actualType = getActualType(variableDeclaration.type, variableDeclaration, MyGoPackage.Literals.VARIABLE_DECLARATION__TYPE);
			if (actualType == nil){
				return;
			}
			var variableType = actualType;
			if (checkAssignmentType(variableType, expressionType, variableDeclaration, MyGoPackage.Literals.VARIABLE_DECLARATION__TYPE)){
				createVariables(variableDeclaration.ids, variableType, variableDeclaration, variableDeclaration.type);
			}
		} else if (variableDeclaration.expression !== null){
			var expressionType = getType(variableDeclaration.expression);
			if (expressionType != nil){
				createVariables(variableDeclaration.ids, expressionType, variableDeclaration, expressionType);
			}
		} else if (variableDeclaration.type !== null){
			var actualType = getActualType(variableDeclaration.type, variableDeclaration, MyGoPackage.Literals.VARIABLE_DECLARATION__TYPE);
			if (actualType == nil){
				return;
			}
			var variableType = actualType;
			createVariables(variableDeclaration.ids, variableType, variableDeclaration, variableDeclaration.type);
		}
	}
	
	@Check
	def checkModel(Model model){
		idNamesToTypes.clear();
		idNamesToFunctions.clear();	
	}
	
	def createVariables(EList<String> variablesNameList, String type, EObject e, String receiverType){
		if (type == voidc){
			error(
				"cannot assign void as type",
				e,
				MyGoPackage.Literals.VARIABLE_DECLARATION__IDS
			)
		}
		for (String variableName: variablesNameList){
			if (variableNamesToTypes.containsKey(variableName)){
				error(
					variableName + " redeclared in this block",
					e,
					MyGoPackage.Literals.VARIABLE_DECLARATION__IDS
				)
			} else {
				variableNamesToTypes.put(variableName, type);
				variableNamesToReceiverTypes.put(variableName, receiverType);
			}
		}
	}
	
	def String getType(Expression e){
		var type = nil;
		if (e instanceof Value){
			var v = (e as Value);
			type = getTypeFromVariableDeclaration(v)
		} else if (e instanceof Variable) {
			var v = (e as Variable);
			var idName = v.id;
			if (variableNamesToTypes.containsKey(idName)){
				type = variableNamesToTypes.get(idName);
			} else {
				error(
					"Undefined: " + idName,
					e,
					MyGoPackage.Literals.VARIABLE__ID
				)
			}
		} else if (e instanceof FuncCall){
			var f = (e as FuncCall);
			type = checkFunctionCall(f, e);
		} else if (e instanceof ExplicitCast){
			var actualType = getActualType(e.type, e, MyGoPackage.Literals.EXPLICIT_CAST__TYPE);
			if (actualType == nil){
				type = nil;
			} else {
				var castType = actualType;
				var expressionType = getType(e.expression);
				if (!checkCastAssignment(castType, expressionType)){
					error(
						"cannot convert " + expressionType + " to " + castType,
						e,
						MyGoPackage.Literals.EXPLICIT_CAST__TYPE
					)
					type = nil;
				} else {
					type = castType;
				}
			}
		} else {
			var operator = e.binaryOp;
			var type1 = getType(e.left);
			var type2 = getType(e.right);
			type = cast(type1, type2, operator, e.left, e.right);
		}
		return type;
	}
	
	def String checkFunctionCall(FuncCall f, EObject e){
		var ret = nil;
		var id = f.id;
		var parametersValues = f.parametersValues.expression;
		if (!idNamesToFunctions.containsKey(id)){
			error(
				"Undefined: " + id,
				e,
				MyGoPackage.Literals.FUNC_CALL__ID
			)
		} else {
			var functionDeclaration = idNamesToFunctions.get(id);
			if (parametersValues.size != functionDeclaration.typesList.size){
				error(
					"Not enough arguments in call to " + id + "\n"
					+ "expected " + functionDeclaration.typesList.size + "\n" 
					+ "get " + parametersValues.size,
					e,
					MyGoPackage.Literals.FUNC_CALL__PARAMETERS_VALUES
				)
			} else {
				var isAllParametersOk = true
				for (var i = 0; i < parametersValues.size() && isAllParametersOk; i++){
					var valueExpression = parametersValues.get(i);
					var argumentType = functionDeclaration.typesList.get(i);
					var valueExpressionType = getType(valueExpression);
					if (valueExpressionType != nil)
					if (!checkCastAssignment(argumentType, valueExpressionType)){
						error(
							"Cannot use " + valueExpressionType 
							+ " as type in " + (i + 1) + "ยบ "+ " argument to " + id + "\n" +
							"expected: " + argumentType, 
							e,
							MyGoPackage.Literals.FUNC_CALL__PARAMETERS_VALUES
						)
						isAllParametersOk = false
					}
				}
				
				if (isAllParametersOk){
					if (checkReceiver(functionDeclaration.receiverType, f.receiverInstance, f, id)){
						ret = functionDeclaration.returnType; 
					}
				}
			}
		}
		
		return ret;
	}
	
	def boolean checkReceiver(String methodReceiverType, ReceiverInstance receiverInstance, FuncCall f, String functionId){
		if (methodReceiverType !== null){
			if (receiverInstance === null){
				error(
					"Expected (" + methodReceiverType + "). before " + functionId,
					f,
					MyGoPackage.Literals.FUNC_CALL__ID
				)
				return false;
			} else {
				if (!variableNamesToReceiverTypes.containsKey(receiverInstance.id)){
					error(
						receiverInstance.id + " must be a declared variable",
						f.receiverInstance,
						MyGoPackage.Literals.RECEIVER_INSTANCE__ID
					)
					return false;
				}
				var receiverInstanceType = variableNamesToReceiverTypes.get(receiverInstance.id);
				if (receiverInstanceType != methodReceiverType){
					error(
						"expected: " + methodReceiverType + "\n" +
						"get: " + receiverInstance.id,
						f.receiverInstance,
						MyGoPackage.Literals.RECEIVER_INSTANCE__ID
					)
					return false;
				} else {
					return true;
				}
			}
		} else {
			if (receiverInstance !== null){
				error(
					"Unexpected " + receiverInstance.id + "." +  " before " + functionId,
					f,
					MyGoPackage.Literals.FUNC_CALL__ID
				)
				return false;
			} else {
				return true;
			}
		}
	}
	
	def String cast (String type1, String type2, String operator, EObject e1, EObject e2){
		var ret = nil;
		if (!isNil(type1) && !isNil(type2)){
			if (isArithmeticOperation(operator)){
				ret = castArithmeticOperation(type1, type2, e1, e2);
			} else if (isRelationalOperational(operator)){
				ret = castRelationalOperation(type1, type2, operator, e1, e2);
			} else  if (isBooleanOperation(operator)){
				ret = castBooleanOperation(type1, type2, operator, e1, e2);
			}
		}

		return ret;
	}
	
	def isBooleanOperation(String operator){
		return 	
			operator == '||' ||
			operator == '&&';
	}
	
	def String castBooleanOperation(String type1, String type2, String operator, EObject e1, EObject e2){
		var ret = nil;
		if (type1 == boolc && type2 == boolc){
			ret = boolc;
		} else {
			error(
				"Expression type must be a boolean " + "(" + operator + " expects a boolean expression )",
				e2,
				MyGoPackage.Literals.EXPRESSION__RIGHT
			)
		}
		return ret;
	}
	
	def boolean isRelationalOperational(String operator){
		return 
			operator == '>' ||
			operator == '>=' ||
			operator == '<' ||
			operator == '<=' ||
			operator == '!=' ||
			operator == '=='; 
	}	
	
	def boolean isSpecialRelationalOperator(String operator){
		return operator == '!=' || operator == '==';
	}
	
	def String castRelationalOperation(String type1, String type2, String operator, EObject e1, EObject e2){
		var ret = nil;
		if (isSpecialRelationalOperator(operator)){
			ret = castSpecialRelationOperation(type1, type2, e1, e2);
		} else {
			if (type1 == boolc || type1 == stringc || type2 == boolc || type2 == stringc){
				if (type1 == boolc || type1 == stringc){
					error(
						"Unable to compare " + type1 + " with " + type2 + " (expression type must be a number)",
						e2,
						MyGoPackage.Literals.EXPRESSION__RIGHT
					)
				}
				if (type2 == boolc || type2 == stringc){
					error(
						"Unable to compare " + type2 + " with " + type1 + " (expression type must be a number)",
						e2,
						MyGoPackage.Literals.EXPRESSION__RIGHT
					)
				}
			} else {
				ret = boolc;	
			}
		}
		return ret;
	}
	
	def String castSpecialRelationOperation(String type1, String type2, EObject e1, EObject e2){
		var ret = nil;
		if (type1 == type2){
			ret = boolc;
		} else {
			if (type1 == boolc || type1 == stringc || type2 == boolc || type2 == stringc){
				error(
					"Unable to compare " + type1 + " with " + type2 + " (incompatible types)",
					e2,
					MyGoPackage.Literals.EXPRESSION__RIGHT
				)
			} else {
				ret = boolc;
			} 
		}
		return ret;
	}
	
	def boolean isArithmeticOperation(String operator){
		return 
			operator == '+' ||
			operator == '-' ||
			operator == '|' ||
			operator == '^' ||
			operator == '*' || 
			operator == '/' ||
			operator == '%' ||
			operator == '<<'|| 
			operator == '>>'||
			operator == '&' || 
			operator == '&^';	
	}
	
	def String castArithmeticOperation(String type1, String type2, EObject e1, EObject e2){
		var ret = nil;
		if (type1 != intc && type1 != floatc){
			error(
				"Unable to do arithmetic operation on " + type1,
				e1,
				MyGoPackage.Literals.EXPRESSION__RIGHT
			)
		} else if (type2 != intc && type2 != floatc){
			error(
				"Unable to do arithmetic operation on " + type2,
				e2,
				MyGoPackage.Literals.EXPRESSION__RIGHT
			)
		} else if (type2 == floatc || type1 == floatc){
			return ret = floatc;
		} else {
			return ret = intc;
		}
		return ret;
	}
	
	def boolean isNil(String type){
		return type == nil;
	}
	
	def boolean checkAssignmentType(String variableType, String expressionType, EObject e, EAttribute ea){
		if (!checkCastAssignment(variableType, expressionType)){
			var message = "constant " + expressionType + " truncated to " + variableType;
			if (expressionType != nil && variableType != nil)
			error(
				message,
				e,
				ea
			)
			return false;
		} else {
			return true;
		}
	}
	
	def boolean checkCastAssignment (String variableType, String expressionType){
		if (variableType.equals(intc)){
			return expressionType.equals(intc) || expressionType.equals(floatc);
		} else if (variableType.equals(floatc)){
			return expressionType.equals(intc) || expressionType.equals(floatc);
		} else if (variableType.equals(boolc)){
			return expressionType.equals(boolc);
		} else if (variableType.equals(stringc)){
			return expressionType.equals(stringc);
		} else {
			return false;
		}
	}

	def String getTypeFromVariableDeclaration(Value v){
		if (v.intValue !== null){
			return intc;
		}
		if (v.floatValue !== null){
			return floatc;
		}
		if (v.boolValue !== null){
			return boolc;
		}
		if (v.stringValue !== null){
			return stringc;
		}
	}
	
	def getActualType(String typeName, EObject e, EAttribute ea){
		if (typeName == 'float64'){
			return floatc;
		} else if (typeName == 'int'){
			return intc;
		} else if (typeName == 'bool'){
			return boolc;
		} else if (typeName == 'string'){
			return stringc;
		} else if (idNamesToTypes.containsKey(typeName)){
			return idNamesToTypes.get(typeName);
		} else {
			error(
				"Undefined type: " + typeName,
				e,
				ea
			)
			return nil;
		}
	}
	
}
