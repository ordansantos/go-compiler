/*
 * generated by Xtext 2.14.0
 */
package org.xtext.compiler.go.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.compiler.go.myGo.Model
import org.xtext.compiler.go.myGo.Assignment
import org.xtext.compiler.go.myGo.Declarations
import org.xtext.compiler.go.myGo.LineCommand
import org.xtext.compiler.go.myGo.Value
import org.xtext.compiler.go.myGo.Expression
import org.xtext.compiler.go.myGo.VariableDeclaration
import org.xtext.compiler.go.myGo.Variable
import java.util.HashMap
import java.util.Map
import org.xtext.compiler.go.myGo.FuncCall
import java.util.ArrayList
import org.xtext.compiler.go.myGo.IdType
import org.xtext.compiler.go.myGo.ReturnStatement
import org.xtext.compiler.go.myGo.ForRange
import org.eclipse.emf.common.util.EList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyGoGenerator extends AbstractGenerator {
	
	String out = "";
	static int PAD = 5; 
	static int SP = 0; 
	static int ALLOC = 4;
	Map<String, Integer> sps;
	static int PC = 8;
	Map<String, Integer> functionPC;
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		var model = resource.contents.head as Model
		out = ""
		SP = 4;
		sps = new HashMap<String, Integer>();
		PC = 8;
		functionPC = new HashMap<String, Integer>()
		var pcmain = 8;
		for (Declarations declarations: model.declarations){
			if (declarations.functionDeclaration !== null){
				if (declarations.functionDeclaration.id == "main"){
					pcmain = PC;
				}
				SP = 4;
				sps.clear();
				functionPC.put(declarations.functionDeclaration.id, PC);
				if (declarations.functionDeclaration.receiver !== null){
					SP += 4;
					sps.put(declarations.functionDeclaration.receiver.idName, SP);
				}
				if (declarations.functionDeclaration.parameters !== null){
					for (IdType idType: declarations.functionDeclaration.parameters.idType){
						SP += 4;
						sps.put(idType.id, SP);
					}
				}
				compileLineCommand(declarations.functionDeclaration.body.lineCommand)
				addCommand(rightPadding("BR") + "*0(SP)");
				
				if (declarations.functionDeclaration.id == "main"){
					addCommand(rightPadding("halt"));
				}
				out += "\n";
			}
		}
		
		var s2 = Integer.toString(0);
		while (s2.length < 4) {
			s2 = "0" + s2;
		}
		var branchCommand = s2 + "  " + rightPadding("BR") + pcmain + "\n";
		
		out = branchCommand + out;
		
		addCommand(rightPadding("halt"));
		
		fsa.generateFile('assembly_go.txt', out);
	}
	
	def void compileLineCommand(EList<LineCommand> lineCommand) {
		for (LineCommand command : lineCommand) {
			if (command instanceof Assignment) {
				var e = command.expression
				var expressionRegister = compile(e);
				ST(command.id, expressionRegister);
			} else if (command instanceof VariableDeclaration) {
				if (command.expression !== null) {
					var e = command.expression
					var expressionRegister = compile(e);
					for (String id : command.ids) {
						ST(id, expressionRegister);
					}
				} else {
					for (String id : command.ids) {
						if (!sps.containsKey(id)) {
							SP += 4;
							sps.put(id, SP);
						}
					}
				}
			} else if (command instanceof ReturnStatement) {
				var spExpression = compile(command.expression);
				addCommand(rightPadding("LD") + "R0, " + getSPValue(spExpression));
				addCommand(rightPadding("ST") + getSPValue(4) + ", R0");
				addCommand(rightPadding("BR") + "*0(SP)");
			} else if (command instanceof FuncCall) {
				// 0 return
				// 4 return value
				// 8 receiver
				// 12 .. n parameters
				var commands = new ArrayList<Integer>();
				var receiverSp = -1;
				if (command.receiverInstance !== null) {
					receiverSp = sps.get(command.receiverInstance.id);
				}
				var paramCounter = 4;

				for (Expression expressionParameter : command.parametersValues.expression) {
					var spExpression = compile(expressionParameter);
					commands.add(spExpression);
				}
				addCommand(rightPadding("ADD") + "SP, SP, #" + (SP + 4));
				if (receiverSp != -1) {
					paramCounter += 4;
					addCommand(rightPadding("LD") + "R0, " + getSPValue(receiverSp - SP - 4));
					addCommand(rightPadding("ST") + getSPValue(paramCounter) + ", R0");
				}
				for (Integer sp : commands) {
					out += "\n";
					paramCounter += 4;
					addCommand(rightPadding("LD") + "R0, " + getSPValue(sp - SP - 4));
					addCommand(rightPadding("ST") + getSPValue(paramCounter) + ", R0");
				}
				addCommand(rightPadding("ST") + "*SP, " + (PC + 16));
				addCommand(rightPadding("BR") + functionPC.get(command.id));
				addCommand(rightPadding("SUB") + "SP, SP, #" + (SP + 4));
			} else if (command instanceof ForRange) {
				var before = -1;
				if (sps.containsKey(command.id1)) {
					before = sps.get(command.id1);
				}
				SP += 4;
				sps.put(command.id1, SP);
				var spi = SP;
				var spn = compile(command.expression);

				addCommand(rightPadding("ST") + getSPValue(spi) + ", #" + 0);
				var begin = PC
				addCommand(rightPadding("LD") + "R0, " + getSPValue(spi));
				addCommand(rightPadding("LD") + "R1, " + getSPValue(spn));
				addCommand(rightPadding("SUB") + "R0, R0, R1");
				var pcAtual = PC;
				var outAtual = out;
				out = "";
				//	addCommand(rightPadding("BGTZ") + "R0, " + "#algo");
				
				compileLineCommand(command.lineCommand) 
				
				addCommand(rightPadding("LD") + "R0, " + getSPValue(spi));
				addCommand(rightPadding("ADD") + "R0, R0, #1");
				addCommand(rightPadding("ST") + getSPValue(spi) + ", R0");
				addCommand(rightPadding("BR") + begin);

				if (before != -1) {
					sps.put(command.id1, before);
				}

				var s2 = Integer.toString(pcAtual);
				while (s2.length < 4) {
					s2 = "0" + s2;
				}
				var branchCommand = s2 + "  " + rightPadding("BGTZ") + "R0, " + PC + "\n";
				out = outAtual + branchCommand + out;
			}
			out += "\n";
		}
	}

	def int compile (Expression e){
		if (e instanceof Value){
			return LD(e);
		} else if (e instanceof Variable){
			return LD(e);
		} else if (e instanceof FuncCall){
			// 0 return
			// 4 return value
			// 8 receiver
			// 12 .. n parameters
			var commands = new ArrayList<Integer>();
			var receiverSp = -1;
			if (e.receiverInstance !== null){
				receiverSp = sps.get(e.receiverInstance.id);
			}
			var paramCounter = 4;
			
			for (Expression expressionParameter: e.parametersValues.expression){
				var spExpression = compile(expressionParameter);
				commands.add(spExpression);

			}
			addCommand(rightPadding("ADD") + "SP, SP, #" + (SP + 4));
			if (receiverSp != -1){
				paramCounter += 4;
				addCommand(rightPadding("LD") + "R0, " + getSPValue(receiverSp - SP - 4));
				addCommand(rightPadding("ST") + getSPValue(paramCounter) + ", R0");
			}
			for (Integer sp: commands){
				out += "\n";
				paramCounter += 4;
				addCommand(rightPadding("LD") + "R0, " + getSPValue(sp - SP - 4));
				addCommand(rightPadding("ST") + getSPValue(paramCounter) + ", R0");
			}
			addCommand(rightPadding("ST") + "*SP, " +  (PC + 16));
			addCommand(rightPadding("BR") + functionPC.get(e.id));
			
			addCommand(rightPadding("LD") + "R0, " + getSPValue(4));
			addCommand(rightPadding("SUB") + "SP, SP, #" + (SP + 4));
			return push();
			
		} else if (e instanceof Expression){
			var spl = compile (e.left);
			var spr = compile (e.right);
			var op = e.binaryOp;
			return binaryOperation(spl, spr, op);
		}
		return -1;
	}
	
	def int LD(Variable v){
		return sps.get(v.id);
	}
	
	def int LD (Value v){
		return push(getValue(v));
	}
	
	def ST (String variableId, int sp){
		if (!sps.containsKey(variableId)){
			SP += 4;
			sps.put(variableId, SP);
		}
		addCommand(rightPadding("LD") + "R0, " + getSPValue(sp));
		addCommand(rightPadding("ST") + getSPValue(sps.get(variableId)) + ", R0");
	}
	
	def String getValue(Value v){
		if (v.intValue !== null){
			return v.intValue;
		}
		if (v.floatValue !== null){
			return v.floatValue;
		}
		if (v.boolValue !== null){
			if (v.boolValue == "true"){
				return "1";
			} else {
				return "0";
			}
		}
		if (v.stringValue !== null){
			return v.stringValue;
		}
	}
	
	def int binaryOperation(int spl, int spr, String op){
		addCommand(rightPadding("LD") + "R0, " + getSPValue(spl));
		addCommand(rightPadding("LD") + "R1, " + getSPValue(spr));
		if (op == "+"){
			return binaryOperationCommand ("ADD");
		} else if (op == "*"){
			return binaryOperationCommand ("MUL");
		} else if (op == "/"){
			return binaryOperationCommand ("DIV");
		} else if (op == "-"){
			return binaryOperationCommand ("SUB");
		} else if (op == "%"){
			return binaryOperationCommand ("REMW");
		} else if (op == "<"){
			addCommand(rightPadding("LD") + "R3, #0")
			addCommand(rightPadding("SUB") + "R0, R0, R1")
			addCommand(rightPadding("BGEZ") + "R0 " + (PC + 16));
			addCommand(rightPadding("LD") + "R3, #1")
			SP += ALLOC;
			addCommand(rightPadding("ST") + getSPValue(SP) + ", R3");
			return SP;
		} else if (op == "<="){
			addCommand(rightPadding("LD") + "R3, #0")
			addCommand(rightPadding("SUB") + "R0, R0, R1")
			addCommand(rightPadding("BGTZ") + "R0 " + (PC + 16));
			addCommand(rightPadding("LD") + "R3, #1")
			SP += ALLOC;
			addCommand(rightPadding("ST") + getSPValue(SP) + ", R3");
			return SP;
		} else if (op == ">"){
			addCommand(rightPadding("LD") + "R3, #0")
			addCommand(rightPadding("SUB") + "R0, R1, R0")
			addCommand(rightPadding("BGEZ") + "R0 " + (PC + 16));
			addCommand(rightPadding("LD") + "R3, #1")
			SP += ALLOC;
			addCommand(rightPadding("ST") + getSPValue(SP) + ", R3");
			return SP;
		} else if (op == ">="){
			addCommand(rightPadding("LD") + "R3, #0")
			addCommand(rightPadding("SUB") + "R0, R1, R0")
			addCommand(rightPadding("BGTZ") + "R0 " + (PC + 16));
			addCommand(rightPadding("LD") + "R3, #1")
			SP += ALLOC;
			addCommand(rightPadding("ST") + getSPValue(SP) + ", R3");
			return SP;
		} else if (op == "=="){
			addCommand(rightPadding("LD") + "R3, #0")
			addCommand(rightPadding("XOR") + "R0, R1, R0")
			addCommand(rightPadding("BGTZ") + "R0 " + (PC + 16));
			addCommand(rightPadding("LD") + "R3, #1")
			SP += ALLOC;
			addCommand(rightPadding("ST") + getSPValue(SP) + ", R3");
			return SP;
		} else if (op == "!="){
			addCommand(rightPadding("LD") + "R3, #1")
			addCommand(rightPadding("XOR") + "R0, R1, R0")
			addCommand(rightPadding("BGTZ") + "R0 " + (PC + 16));
			addCommand(rightPadding("LD") + "R3, #0")
			SP += ALLOC;
			addCommand(rightPadding("ST") + getSPValue(SP) + ", R3");
			return SP;
		}
		return -1;
	}
	
	def int binaryOperationCommand (String operationCommand){
		addCommand(rightPadding(operationCommand) + "R0, R0, R1");
		return push();
	} 
	
	def String rightPadding(String s){
		var sb = new StringBuilder();
		sb.append(s);
		while (sb.length < PAD){
			sb.append(" ");
		}
		return sb.toString;
	}
	
	def String getSPValue(int p){
		return "*" + p + "(SP)";
	}
	
	def int push(String constant){
		SP += ALLOC;
		addCommand(rightPadding("ST") + getSPValue(SP) + ", #" + constant);
		return SP;
	}
	
	def int push(){
		SP += ALLOC;
		addCommand(rightPadding("ST") + getSPValue(SP) + ", R0");
		return SP;
	}
	
	def addCommand(String s){
		var s2 = Integer.toString(PC);
		while (s2.length < 4){
			s2 = "0" + s2;
		}
		out += s2 + "  " + s + "\n";
		PC += 8;
	}

}
