/**
 * generated by Xtext 2.14.0
 */
package org.xtext.compiler.go.validation;

import com.google.common.base.Objects;
import java.util.HashMap;
import java.util.HashSet;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.xtext.compiler.go.myGo.Assignment;
import org.xtext.compiler.go.myGo.ExplicitCast;
import org.xtext.compiler.go.myGo.Expression;
import org.xtext.compiler.go.myGo.ForRange;
import org.xtext.compiler.go.myGo.FuncCall;
import org.xtext.compiler.go.myGo.FunctionDeclaration;
import org.xtext.compiler.go.myGo.IdType;
import org.xtext.compiler.go.myGo.LineCommand;
import org.xtext.compiler.go.myGo.Model;
import org.xtext.compiler.go.myGo.MyGoPackage;
import org.xtext.compiler.go.myGo.ParametersDeclaration;
import org.xtext.compiler.go.myGo.Receiver;
import org.xtext.compiler.go.myGo.ReceiverInstance;
import org.xtext.compiler.go.myGo.ReturnStatement;
import org.xtext.compiler.go.myGo.TypeDeclaration;
import org.xtext.compiler.go.myGo.Value;
import org.xtext.compiler.go.myGo.Variable;
import org.xtext.compiler.go.myGo.VariableDeclaration;
import org.xtext.compiler.go.validation.AbstractMyGoValidator;
import org.xtext.compiler.go.validation.Function;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MyGoValidator extends AbstractMyGoValidator {
  public static HashMap<String, Function> idNamesToFunctions = new HashMap<String, Function>();
  
  public static HashMap<String, String> idNamesToTypes = new HashMap<String, String>();
  
  public HashMap<String, String> variableNamesToTypes;
  
  public HashMap<String, String> variableNamesToReceiverTypes;
  
  public final String intc = "int";
  
  public final String stringc = "string";
  
  public final String boolc = "bool";
  
  public final String floatc = "float64";
  
  public final String nil = "nil";
  
  public final String voidc = "void";
  
  @Check
  public void checkFunctionDeclaration(final FunctionDeclaration functionDeclaration) {
    String id = functionDeclaration.getId();
    boolean _checkNameNotDeclared = this.checkNameNotDeclared(id, functionDeclaration, MyGoPackage.Literals.FUNCTION_DECLARATION__ID);
    if (_checkNameNotDeclared) {
      Function f = new Function();
      String _type = functionDeclaration.getType();
      boolean _tripleNotEquals = (_type != null);
      if (_tripleNotEquals) {
        String actualType = this.getActualType(functionDeclaration.getType(), functionDeclaration, MyGoPackage.Literals.FUNCTION_DECLARATION__TYPE);
        boolean _equals = Objects.equal(actualType, this.nil);
        if (_equals) {
          return;
        }
        f.returnType = actualType;
      } else {
        f.returnType = this.voidc;
      }
      HashSet<String> uniqueParametersName = new HashSet<String>();
      HashMap<String, String> _hashMap = new HashMap<String, String>();
      this.variableNamesToTypes = _hashMap;
      HashMap<String, String> _hashMap_1 = new HashMap<String, String>();
      this.variableNamesToReceiverTypes = _hashMap_1;
      Receiver _receiver = functionDeclaration.getReceiver();
      boolean _tripleNotEquals_1 = (_receiver != null);
      if (_tripleNotEquals_1) {
        f.receiverType = functionDeclaration.getReceiver().getIdType();
        String actualType_1 = this.getActualType(functionDeclaration.getReceiver().getIdType(), functionDeclaration.getReceiver(), MyGoPackage.Literals.RECEIVER__ID_TYPE);
        boolean _equals_1 = Objects.equal(actualType_1, this.nil);
        if (_equals_1) {
          return;
        }
        this.variableNamesToTypes.put(functionDeclaration.getReceiver().getIdName(), actualType_1);
        this.variableNamesToReceiverTypes.put(functionDeclaration.getReceiver().getIdName(), functionDeclaration.getReceiver().getIdType());
      }
      ParametersDeclaration _parameters = functionDeclaration.getParameters();
      boolean _tripleNotEquals_2 = (_parameters != null);
      if (_tripleNotEquals_2) {
        EList<IdType> parameters = functionDeclaration.getParameters().getIdType();
        for (final IdType idType : parameters) {
          {
            boolean _contains = uniqueParametersName.contains(idType.getId());
            if (_contains) {
              String _id = idType.getId();
              String _plus = ("Duplicate argument " + _id);
              this.error(_plus, idType, 
                MyGoPackage.Literals.ID_TYPE__ID);
              return;
            }
            String actualType_2 = this.getActualType(idType.getType(), idType, MyGoPackage.Literals.ID_TYPE__TYPE);
            boolean _equals_2 = Objects.equal(actualType_2, this.nil);
            if (_equals_2) {
              return;
            }
            f.typesList.add(actualType_2);
            this.variableNamesToTypes.put(idType.getId(), actualType_2);
            this.variableNamesToReceiverTypes.put(idType.getId(), idType.getType());
          }
        }
      }
      MyGoValidator.idNamesToFunctions.put(id, f);
      boolean returnDeclared = this.checkLineCommands(functionDeclaration.getBody().getLineCommand(), f);
      if (((!returnDeclared) && (!Objects.equal(f.returnType, this.voidc)))) {
        this.error(
          "missing return at end of function", functionDeclaration, 
          MyGoPackage.Literals.FUNCTION_DECLARATION__ID);
      }
    }
  }
  
  public boolean checkLineCommands(final EList<LineCommand> lineCommands, final Function f) {
    boolean returnDeclared = false;
    for (final LineCommand command : lineCommands) {
      if ((command instanceof VariableDeclaration)) {
        this.checkVariableDeclaration(((VariableDeclaration)command));
      } else {
        if ((command instanceof ReturnStatement)) {
          String returnedType = this.getType(((ReturnStatement)command).getExpression());
          boolean _notEquals = (!Objects.equal(returnedType, this.nil));
          if (_notEquals) {
            boolean _checkCastAssignment = this.checkCastAssignment(f.returnType, returnedType);
            boolean _not = (!_checkCastAssignment);
            if (_not) {
              this.error(
                (((("Cannot use " + returnedType) + " as type ") + 
                  f.returnType) + " in return argument"), command, 
                MyGoPackage.Literals.RETURN_STATEMENT__EXPRESSION);
            } else {
              returnDeclared = true;
            }
          }
        } else {
          if ((command instanceof ForRange)) {
            String expressionType = this.getType(((ForRange)command).getExpression());
            boolean _notEquals_1 = (!Objects.equal(expressionType, this.stringc));
            if (_notEquals_1) {
              this.error(
                ("Cannot range over " + expressionType), command, 
                MyGoPackage.Literals.FOR_RANGE__EXPRESSION);
            } else {
              HashMap<String, String> scopeVariableNamesToTypes = new HashMap<String, String>(this.variableNamesToTypes);
              HashMap<String, String> scopevariableNamesToReceiverTypes = new HashMap<String, String>(this.variableNamesToReceiverTypes);
              this.variableNamesToTypes.put(((ForRange)command).getId1(), this.intc);
              this.variableNamesToReceiverTypes.put(((ForRange)command).getId1(), this.intc);
              String _id2 = ((ForRange)command).getId2();
              boolean _tripleNotEquals = (_id2 != null);
              if (_tripleNotEquals) {
                this.variableNamesToTypes.put(((ForRange)command).getId2(), this.intc);
                this.variableNamesToReceiverTypes.put(((ForRange)command).getId2(), this.intc);
              }
              boolean _checkLineCommands = this.checkLineCommands(((ForRange)command).getLineCommand(), f);
              if (_checkLineCommands) {
                returnDeclared = true;
              }
              this.variableNamesToTypes = scopeVariableNamesToTypes;
              this.variableNamesToReceiverTypes = scopevariableNamesToReceiverTypes;
            }
          } else {
            if ((command instanceof FuncCall)) {
              String funcCallType = this.getType(((Expression)command));
              boolean _notEquals_2 = (!Objects.equal(funcCallType, this.nil));
              if (_notEquals_2) {
                boolean _notEquals_3 = (!Objects.equal(funcCallType, this.voidc));
                if (_notEquals_3) {
                  String _id = ((FuncCall)command).getId();
                  String _plus = (_id + " evaluated but not used");
                  this.warning(_plus, command, 
                    MyGoPackage.Literals.FUNC_CALL__ID);
                }
              }
            } else {
              if ((command instanceof Assignment)) {
                String idName = ((Assignment)command).getId();
                boolean _containsKey = this.variableNamesToTypes.containsKey(idName);
                boolean _not_1 = (!_containsKey);
                if (_not_1) {
                  this.error(
                    ("Undefined: " + idName), command, 
                    MyGoPackage.Literals.ASSIGNMENT__ID);
                } else {
                  String idType = this.variableNamesToTypes.get(idName);
                  String expressionType_1 = this.getType(((Assignment)command).getExpression());
                  boolean _notEquals_4 = (!Objects.equal(expressionType_1, this.nil));
                  if (_notEquals_4) {
                    this.checkAssignmentType(idType, expressionType_1, command, MyGoPackage.Literals.ASSIGNMENT__ID);
                  }
                }
              }
            }
          }
        }
      }
    }
    return returnDeclared;
  }
  
  @Check
  public void typeDeclaration(final TypeDeclaration typeDeclaration) {
    String actualType = this.getActualType(typeDeclaration.getType(), typeDeclaration, MyGoPackage.Literals.TYPE_DECLARATION__TYPE);
    boolean _equals = Objects.equal(actualType, this.nil);
    if (_equals) {
      return;
    }
    String newTypeName = actualType;
    String newTypeId = typeDeclaration.getId();
    boolean _checkNameNotDeclared = this.checkNameNotDeclared(newTypeId, typeDeclaration, MyGoPackage.Literals.TYPE_DECLARATION__ID);
    if (_checkNameNotDeclared) {
      MyGoValidator.idNamesToTypes.put(newTypeId, newTypeName);
    }
  }
  
  public boolean checkNameNotDeclared(final String idName, final EObject e, final EAttribute ea) {
    if ((MyGoValidator.idNamesToFunctions.containsKey(idName) || MyGoValidator.idNamesToTypes.containsKey(idName))) {
      this.error(
        (idName + " redeclared in this block"), e, ea);
      return false;
    } else {
      return true;
    }
  }
  
  public void checkVariableDeclaration(final VariableDeclaration variableDeclaration) {
    if (((variableDeclaration.getExpression() != null) && (variableDeclaration.getType() != null))) {
      String expressionType = this.getType(variableDeclaration.getExpression());
      String actualType = this.getActualType(variableDeclaration.getType(), variableDeclaration, MyGoPackage.Literals.VARIABLE_DECLARATION__TYPE);
      boolean _equals = Objects.equal(actualType, this.nil);
      if (_equals) {
        return;
      }
      String variableType = actualType;
      boolean _checkAssignmentType = this.checkAssignmentType(variableType, expressionType, variableDeclaration, MyGoPackage.Literals.VARIABLE_DECLARATION__TYPE);
      if (_checkAssignmentType) {
        this.createVariables(variableDeclaration.getIds(), variableType, variableDeclaration, variableDeclaration.getType());
      }
    } else {
      Expression _expression = variableDeclaration.getExpression();
      boolean _tripleNotEquals = (_expression != null);
      if (_tripleNotEquals) {
        String expressionType_1 = this.getType(variableDeclaration.getExpression());
        boolean _notEquals = (!Objects.equal(expressionType_1, this.nil));
        if (_notEquals) {
          this.createVariables(variableDeclaration.getIds(), expressionType_1, variableDeclaration, expressionType_1);
        }
      } else {
        String _type = variableDeclaration.getType();
        boolean _tripleNotEquals_1 = (_type != null);
        if (_tripleNotEquals_1) {
          String actualType_1 = this.getActualType(variableDeclaration.getType(), variableDeclaration, MyGoPackage.Literals.VARIABLE_DECLARATION__TYPE);
          boolean _equals_1 = Objects.equal(actualType_1, this.nil);
          if (_equals_1) {
            return;
          }
          String variableType_1 = actualType_1;
          this.createVariables(variableDeclaration.getIds(), variableType_1, variableDeclaration, variableDeclaration.getType());
        }
      }
    }
  }
  
  @Check
  public void checkModel(final Model model) {
    MyGoValidator.idNamesToTypes.clear();
    MyGoValidator.idNamesToFunctions.clear();
  }
  
  public void createVariables(final EList<String> variablesNameList, final String type, final EObject e, final String receiverType) {
    boolean _equals = Objects.equal(type, this.voidc);
    if (_equals) {
      this.error(
        "cannot assign void as type", e, 
        MyGoPackage.Literals.VARIABLE_DECLARATION__IDS);
    }
    for (final String variableName : variablesNameList) {
      boolean _containsKey = this.variableNamesToTypes.containsKey(variableName);
      if (_containsKey) {
        this.error(
          (variableName + " redeclared in this block"), e, 
          MyGoPackage.Literals.VARIABLE_DECLARATION__IDS);
      } else {
        this.variableNamesToTypes.put(variableName, type);
        this.variableNamesToReceiverTypes.put(variableName, receiverType);
      }
    }
  }
  
  public String getType(final Expression e) {
    String type = this.nil;
    if ((e instanceof Value)) {
      Value v = ((Value) e);
      type = this.getTypeFromVariableDeclaration(v);
    } else {
      if ((e instanceof Variable)) {
        Variable v_1 = ((Variable) e);
        String idName = v_1.getId();
        boolean _containsKey = this.variableNamesToTypes.containsKey(idName);
        if (_containsKey) {
          type = this.variableNamesToTypes.get(idName);
        } else {
          this.error(
            ("Undefined: " + idName), e, 
            MyGoPackage.Literals.VARIABLE__ID);
        }
      } else {
        if ((e instanceof FuncCall)) {
          FuncCall f = ((FuncCall) e);
          type = this.checkFunctionCall(f, e);
        } else {
          if ((e instanceof ExplicitCast)) {
            String actualType = this.getActualType(((ExplicitCast)e).getType(), e, MyGoPackage.Literals.EXPLICIT_CAST__TYPE);
            boolean _equals = Objects.equal(actualType, this.nil);
            if (_equals) {
              type = this.nil;
            } else {
              String castType = actualType;
              String expressionType = this.getType(((ExplicitCast)e).getExpression());
              boolean _checkCastAssignment = this.checkCastAssignment(castType, expressionType);
              boolean _not = (!_checkCastAssignment);
              if (_not) {
                this.error(
                  ((("cannot convert " + expressionType) + " to ") + castType), e, 
                  MyGoPackage.Literals.EXPLICIT_CAST__TYPE);
                type = this.nil;
              } else {
                type = castType;
              }
            }
          } else {
            String operator = e.getBinaryOp();
            String type1 = this.getType(e.getLeft());
            String type2 = this.getType(e.getRight());
            type = this.cast(type1, type2, operator, e.getLeft(), e.getRight());
          }
        }
      }
    }
    return type;
  }
  
  public String checkFunctionCall(final FuncCall f, final EObject e) {
    String ret = this.nil;
    String id = f.getId();
    EList<Expression> parametersValues = f.getParametersValues().getExpression();
    boolean _containsKey = MyGoValidator.idNamesToFunctions.containsKey(id);
    boolean _not = (!_containsKey);
    if (_not) {
      this.error(
        ("Undefined: " + id), e, 
        MyGoPackage.Literals.FUNC_CALL__ID);
    } else {
      Function functionDeclaration = MyGoValidator.idNamesToFunctions.get(id);
      int _size = parametersValues.size();
      int _size_1 = functionDeclaration.typesList.size();
      boolean _notEquals = (_size != _size_1);
      if (_notEquals) {
        int _size_2 = functionDeclaration.typesList.size();
        String _plus = (((("Not enough arguments in call to " + id) + "\n") + "expected ") + Integer.valueOf(_size_2));
        String _plus_1 = (_plus + "\n");
        String _plus_2 = (_plus_1 + "get ");
        int _size_3 = parametersValues.size();
        String _plus_3 = (_plus_2 + Integer.valueOf(_size_3));
        this.error(_plus_3, e, 
          MyGoPackage.Literals.FUNC_CALL__PARAMETERS_VALUES);
      } else {
        boolean isAllParametersOk = true;
        for (int i = 0; ((i < parametersValues.size()) && isAllParametersOk); i++) {
          {
            Expression valueExpression = parametersValues.get(i);
            String argumentType = functionDeclaration.typesList.get(i);
            String valueExpressionType = this.getType(valueExpression);
            boolean _notEquals_1 = (!Objects.equal(valueExpressionType, this.nil));
            if (_notEquals_1) {
              boolean _checkCastAssignment = this.checkCastAssignment(argumentType, valueExpressionType);
              boolean _not_1 = (!_checkCastAssignment);
              if (_not_1) {
                this.error(
                  ((((((((("Cannot use " + valueExpressionType) + " as type in ") + Integer.valueOf((i + 1))) + "ยบ ") + " argument to ") + id) + "\n") + 
                    "expected: ") + argumentType), e, 
                  MyGoPackage.Literals.FUNC_CALL__PARAMETERS_VALUES);
                isAllParametersOk = false;
              }
            }
          }
        }
        if (isAllParametersOk) {
          boolean _checkReceiver = this.checkReceiver(functionDeclaration.receiverType, f.getReceiverInstance(), f, id);
          if (_checkReceiver) {
            ret = functionDeclaration.returnType;
          }
        }
      }
    }
    return ret;
  }
  
  public boolean checkReceiver(final String methodReceiverType, final ReceiverInstance receiverInstance, final FuncCall f, final String functionId) {
    if ((methodReceiverType != null)) {
      if ((receiverInstance == null)) {
        this.error(
          ((("Expected (" + methodReceiverType) + "). before ") + functionId), f, 
          MyGoPackage.Literals.FUNC_CALL__ID);
        return false;
      } else {
        boolean _containsKey = this.variableNamesToReceiverTypes.containsKey(receiverInstance.getId());
        boolean _not = (!_containsKey);
        if (_not) {
          String _id = receiverInstance.getId();
          String _plus = (_id + " must be a declared variable");
          this.error(_plus, 
            f.getReceiverInstance(), 
            MyGoPackage.Literals.RECEIVER_INSTANCE__ID);
          return false;
        }
        String receiverInstanceType = this.variableNamesToReceiverTypes.get(receiverInstance.getId());
        boolean _notEquals = (!Objects.equal(receiverInstanceType, methodReceiverType));
        if (_notEquals) {
          String _id_1 = receiverInstance.getId();
          String _plus_1 = (((("expected: " + methodReceiverType) + "\n") + 
            "get: ") + _id_1);
          this.error(_plus_1, 
            f.getReceiverInstance(), 
            MyGoPackage.Literals.RECEIVER_INSTANCE__ID);
          return false;
        } else {
          return true;
        }
      }
    } else {
      if ((receiverInstance != null)) {
        String _id_2 = receiverInstance.getId();
        String _plus_2 = ("Unexpected " + _id_2);
        String _plus_3 = (_plus_2 + ".");
        String _plus_4 = (_plus_3 + " before ");
        String _plus_5 = (_plus_4 + functionId);
        this.error(_plus_5, f, 
          MyGoPackage.Literals.FUNC_CALL__ID);
        return false;
      } else {
        return true;
      }
    }
  }
  
  public String cast(final String type1, final String type2, final String operator, final EObject e1, final EObject e2) {
    String ret = this.nil;
    if (((!this.isNil(type1)) && (!this.isNil(type2)))) {
      boolean _isArithmeticOperation = this.isArithmeticOperation(operator);
      if (_isArithmeticOperation) {
        ret = this.castArithmeticOperation(type1, type2, e1, e2);
      } else {
        boolean _isRelationalOperational = this.isRelationalOperational(operator);
        if (_isRelationalOperational) {
          ret = this.castRelationalOperation(type1, type2, operator, e1, e2);
        } else {
          boolean _isBooleanOperation = this.isBooleanOperation(operator);
          if (_isBooleanOperation) {
            ret = this.castBooleanOperation(type1, type2, operator, e1, e2);
          }
        }
      }
    }
    return ret;
  }
  
  public boolean isBooleanOperation(final String operator) {
    return (Objects.equal(operator, "||") || 
      Objects.equal(operator, "&&"));
  }
  
  public String castBooleanOperation(final String type1, final String type2, final String operator, final EObject e1, final EObject e2) {
    String ret = this.nil;
    if ((Objects.equal(type1, this.boolc) && Objects.equal(type2, this.boolc))) {
      ret = this.boolc;
    } else {
      this.error(
        ((("Expression type must be a boolean " + "(") + operator) + " expects a boolean expression )"), e2, 
        MyGoPackage.Literals.EXPRESSION__RIGHT);
    }
    return ret;
  }
  
  public boolean isRelationalOperational(final String operator) {
    return (((((Objects.equal(operator, ">") || 
      Objects.equal(operator, ">=")) || 
      Objects.equal(operator, "<")) || 
      Objects.equal(operator, "<=")) || 
      Objects.equal(operator, "!=")) || 
      Objects.equal(operator, "=="));
  }
  
  public boolean isSpecialRelationalOperator(final String operator) {
    return (Objects.equal(operator, "!=") || Objects.equal(operator, "=="));
  }
  
  public String castRelationalOperation(final String type1, final String type2, final String operator, final EObject e1, final EObject e2) {
    String ret = this.nil;
    boolean _isSpecialRelationalOperator = this.isSpecialRelationalOperator(operator);
    if (_isSpecialRelationalOperator) {
      ret = this.castSpecialRelationOperation(type1, type2, e1, e2);
    } else {
      if ((((Objects.equal(type1, this.boolc) || Objects.equal(type1, this.stringc)) || Objects.equal(type2, this.boolc)) || Objects.equal(type2, this.stringc))) {
        if ((Objects.equal(type1, this.boolc) || Objects.equal(type1, this.stringc))) {
          this.error(
            (((("Unable to compare " + type1) + " with ") + type2) + " (expression type must be a number)"), e2, 
            MyGoPackage.Literals.EXPRESSION__RIGHT);
        }
        if ((Objects.equal(type2, this.boolc) || Objects.equal(type2, this.stringc))) {
          this.error(
            (((("Unable to compare " + type2) + " with ") + type1) + " (expression type must be a number)"), e2, 
            MyGoPackage.Literals.EXPRESSION__RIGHT);
        }
      } else {
        ret = this.boolc;
      }
    }
    return ret;
  }
  
  public String castSpecialRelationOperation(final String type1, final String type2, final EObject e1, final EObject e2) {
    String ret = this.nil;
    boolean _equals = Objects.equal(type1, type2);
    if (_equals) {
      ret = this.boolc;
    } else {
      if ((((Objects.equal(type1, this.boolc) || Objects.equal(type1, this.stringc)) || Objects.equal(type2, this.boolc)) || Objects.equal(type2, this.stringc))) {
        this.error(
          (((("Unable to compare " + type1) + " with ") + type2) + " (incompatible types)"), e2, 
          MyGoPackage.Literals.EXPRESSION__RIGHT);
      } else {
        ret = this.boolc;
      }
    }
    return ret;
  }
  
  public boolean isArithmeticOperation(final String operator) {
    return ((((((((((Objects.equal(operator, "+") || 
      Objects.equal(operator, "-")) || 
      Objects.equal(operator, "|")) || 
      Objects.equal(operator, "^")) || 
      Objects.equal(operator, "*")) || 
      Objects.equal(operator, "/")) || 
      Objects.equal(operator, "%")) || 
      Objects.equal(operator, "<<")) || 
      Objects.equal(operator, ">>")) || 
      Objects.equal(operator, "&")) || 
      Objects.equal(operator, "&^"));
  }
  
  public String castArithmeticOperation(final String type1, final String type2, final EObject e1, final EObject e2) {
    String ret = this.nil;
    if (((!Objects.equal(type1, this.intc)) && (!Objects.equal(type1, this.floatc)))) {
      this.error(
        ("Unable to do arithmetic operation on " + type1), e1, 
        MyGoPackage.Literals.EXPRESSION__RIGHT);
    } else {
      if (((!Objects.equal(type2, this.intc)) && (!Objects.equal(type2, this.floatc)))) {
        this.error(
          ("Unable to do arithmetic operation on " + type2), e2, 
          MyGoPackage.Literals.EXPRESSION__RIGHT);
      } else {
        if ((Objects.equal(type2, this.floatc) || Objects.equal(type1, this.floatc))) {
          return ret = this.floatc;
        } else {
          return ret = this.intc;
        }
      }
    }
    return ret;
  }
  
  public boolean isNil(final String type) {
    return Objects.equal(type, this.nil);
  }
  
  public boolean checkAssignmentType(final String variableType, final String expressionType, final EObject e, final EAttribute ea) {
    boolean _checkCastAssignment = this.checkCastAssignment(variableType, expressionType);
    boolean _not = (!_checkCastAssignment);
    if (_not) {
      String message = ((("constant " + expressionType) + " truncated to ") + variableType);
      if (((!Objects.equal(expressionType, this.nil)) && (!Objects.equal(variableType, this.nil)))) {
        this.error(message, e, ea);
      }
      return false;
    } else {
      return true;
    }
  }
  
  public boolean checkCastAssignment(final String variableType, final String expressionType) {
    boolean _equals = variableType.equals(this.intc);
    if (_equals) {
      return (expressionType.equals(this.intc) || expressionType.equals(this.floatc));
    } else {
      boolean _equals_1 = variableType.equals(this.floatc);
      if (_equals_1) {
        return (expressionType.equals(this.intc) || expressionType.equals(this.floatc));
      } else {
        boolean _equals_2 = variableType.equals(this.boolc);
        if (_equals_2) {
          return expressionType.equals(this.boolc);
        } else {
          boolean _equals_3 = variableType.equals(this.stringc);
          if (_equals_3) {
            return expressionType.equals(this.stringc);
          } else {
            return false;
          }
        }
      }
    }
  }
  
  public String getTypeFromVariableDeclaration(final Value v) {
    String _intValue = v.getIntValue();
    boolean _tripleNotEquals = (_intValue != null);
    if (_tripleNotEquals) {
      return this.intc;
    }
    String _floatValue = v.getFloatValue();
    boolean _tripleNotEquals_1 = (_floatValue != null);
    if (_tripleNotEquals_1) {
      return this.floatc;
    }
    String _boolValue = v.getBoolValue();
    boolean _tripleNotEquals_2 = (_boolValue != null);
    if (_tripleNotEquals_2) {
      return this.boolc;
    }
    String _stringValue = v.getStringValue();
    boolean _tripleNotEquals_3 = (_stringValue != null);
    if (_tripleNotEquals_3) {
      return this.stringc;
    }
    return null;
  }
  
  public String getActualType(final String typeName, final EObject e, final EAttribute ea) {
    boolean _equals = Objects.equal(typeName, "float64");
    if (_equals) {
      return this.floatc;
    } else {
      boolean _equals_1 = Objects.equal(typeName, "int");
      if (_equals_1) {
        return this.intc;
      } else {
        boolean _equals_2 = Objects.equal(typeName, "bool");
        if (_equals_2) {
          return this.boolc;
        } else {
          boolean _equals_3 = Objects.equal(typeName, "string");
          if (_equals_3) {
            return this.stringc;
          } else {
            boolean _containsKey = MyGoValidator.idNamesToTypes.containsKey(typeName);
            if (_containsKey) {
              return MyGoValidator.idNamesToTypes.get(typeName);
            } else {
              this.error(
                ("Undefined type: " + typeName), e, ea);
              return this.nil;
            }
          }
        }
      }
    }
  }
}
